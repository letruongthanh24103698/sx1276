/*
 * SCI_SX1276.c
 *
 *  Created on: May 29, 2020
 *      Author: Le Truong Thanh
 *      Comment: DO NOT EDIT THIS FILE
 *      First version for RAK4200
 */
#include "SCI_SX1276.h"
#include <stdio.h>

/*****************************************************************************************************************/
/*													GLOBAL VARIABLES											 */
/*****************************************************************************************************************/
extern HCI_SX1276_t HCI_SX1276;

const int8_t TxPowers[]    = { 20, 14, 11,  8,  5,  2 };
const uint8_t Datarates[]  = { 12, 11, 10,  9,  8,  7,  7, 50 };
const uint8_t MaxPayloadOfDatarate[] = { 51, 51, 51, 115, 242, 242, 242, 242 };
/*****************************************************************************************************************/
/*													PRIVATE FUNCTION											 */
/*****************************************************************************************************************/
static void SX1276Reset(void);
static uint8_t SX1276Read(uint8_t adr);
static void SX1276ReadBuffer(uint8_t adr,uint8_t *buffer,uint8_t length);
static void SX1276Write(uint8_t adr, uint8_t data);
static void SX1276WriteBuffer(uint8_t adr, uint8_t *buffer, uint8_t length);
static uint8_t SX1276InOut(uint8_t adr);
static void RxChainCalibration(void);
static void SX1276SetOpMode(uint8_t OpMode);
static void SX1276SetModem( RadioModems_t modem );
static void SX1276SetPublicNetwork(bool enable);
static void SX1276Init(void);
static void SX1276Sleep(void);
static void SX1276Send(TxConfig_t txConfig);
static void SX1276PrepareFrame(uint8_t *Data, uint16_t size);
static void SX1276SetChannel(uint32_t freq);
static void SX1276SetMacPayloadLength(RadioModems_t Modem, uint8_t length);
static void SX1276SetTxConfig(TxConfig_t TxConfig);//( RadioModems_t modem, int8_t power, uint32_t fdev,
        //uint32_t bandwidth, uint32_t datarate,
        //uint8_t coderate, uint16_t preambleLen,
        //bool fixLen, bool crcOn, bool freqHopOn,
        //uint8_t hopPeriod, bool iqInverted, uint32_t timeout );
static void SX1276SetStby();
static void SX1276SetRfTxPower( int8_t power );
static void SX1276SetTx(bool FreqHopOn);
static void DIO0_IRQ(void);
static void DIO1_IRQ(void);
static void DIO2_IRQ(void);
static void DIO3_IRQ(void);
static void OnTxDone(void);
static void OnTxTimeout(void);
static void OnRxDone(uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr);
static void OnRxWindow1Timeout(void);
static void OnRxWindow2Timeout(void);
static void SX1276SetAntSw(uint8_t opmode);
static void SetUserFunction(SX1276_UserFunction_t UserFunction);
static void NullFunction(void);
static uint32_t SX1276Random( void );
static bool SX1276RxWindowSetup(RxConfig_t RxConfig);
static void SX1276SetRxConfig(RxConfig_t _RxConfig);
static void SX1276SetRx(RxConfig_t RxConfig);
/*****************************************************************************************************************/
/*											APPLICATION PROGRAMMING INTERFACE									 */
/*****************************************************************************************************************/
SCI_SX1276_t SCI_SX1276 ={
		.InOut				= &SX1276InOut,
		.Read				= &SX1276Read,
		.ReadBuffer			= &SX1276ReadBuffer,
		.Write				= &SX1276Write,
		.WriteBuffer		= &SX1276WriteBuffer,
		.RxChainCalibration	= &RxChainCalibration,
		.SetOpMode			= &SX1276SetOpMode,
		.SetModem			= &SX1276SetModem,
		.Init				= &SX1276Init,
		.Sleep				= &SX1276Sleep,
		.Send				= &SX1276Send,
		.Prepareframe		= &SX1276PrepareFrame,
		.SetChannel			= &SX1276SetChannel,
		.SetMaxPayloadLength= &SX1276SetMacPayloadLength,
		.SetTxConfig		= &SX1276SetTxConfig,
		.SetStby			= &SX1276SetStby,
		.DIO0_IRQ			= &DIO0_IRQ,
		.DIO1_IRQ			= &DIO1_IRQ,
		.DIO2_IRQ			= &DIO2_IRQ,
		.DIO3_IRQ			= &DIO3_IRQ,
		.print				= &printf,
		.SetUserFunction	= &SetUserFunction,
		.Random				= &SX1276Random,
		.RxWindowSetup		= &SX1276RxWindowSetup,
		.SetRx				= &SX1276SetRx,
		.SetRxConfig		= &SX1276SetRxConfig
};

SX1276_t SX1276={
		.HCI				= &HCI_SX1276,
		.SCI				= &SCI_SX1276
};
/*****************************************************************************************************************/
/*													PRIVATE VARIABLES											 */
/*****************************************************************************************************************/
const RadioRegisters_t RadioRegsInit[] = RADIO_INIT_REGISTERS_VALUE;

/*****************************************************************************************************************/
/*													FUNCTION IMPLEMENT									 	 	 */
/*****************************************************************************************************************/
void SX1276Reset(void)
{
	HCI_SX1276.GPIOWrite(NRESET_GPIO_Port,NRESET_Pin,0);
	HCI_SX1276.Delay(10);
	HCI_SX1276.GPIOWrite(NRESET_GPIO_Port,NRESET_Pin,1);
	HCI_SX1276.Delay(60);
}

uint8_t SX1276InOut(uint8_t outData)
{
    uint8_t rxData = 0;

    HCI_SX1276.RunSPI(SPI_MODE_ENABLE);
    HCI_SX1276.SPI_COMMAND_IRQ(SPI_MODE_DISABLE);


    rxData=HCI_SX1276.SendGetData(outData);


    HCI_SX1276.SPI_COMMAND_IRQ(SPI_MODE_ENABLE);
    HCI_SX1276.RunSPI(SPI_MODE_DISABLE);

    return( rxData );
}

uint8_t SX1276Read(uint8_t adr)
{
	uint8_t data;
	SX1276ReadBuffer(adr,&data,1);
	return data;
}

void SX1276ReadBuffer(uint8_t adr, uint8_t *buffer, uint8_t length)
{
    uint8_t i;

    //NSS = 0;
    HCI_SX1276.GPIOWrite(SPI1_NSS_GPIO_Port,SPI1_NSS_Pin,0);

    SX1276InOut( adr & 0x7F );

    for( i = 0; i < length; i++ )
    {
        buffer[i] = SX1276InOut( 0 );
    }

    //NSS = 1;
    HCI_SX1276.GPIOWrite(SPI1_NSS_GPIO_Port,SPI1_NSS_Pin,1);
}

void SX1276Write(uint8_t adr, uint8_t data)
{
	SX1276WriteBuffer(adr,&data,1);
}

void SX1276WriteBuffer(uint8_t adr, uint8_t *buffer, uint8_t length)
{
    //NSS = 0;
	HCI_SX1276.GPIOWrite(SPI1_NSS_GPIO_Port,SPI1_NSS_Pin,0);

    SX1276InOut( adr | 0x80 );
    for( uint8_t i = 0; i < length; i++ )
    {
        SX1276InOut( buffer[i] );
    }

    //NSS = 1;
    HCI_SX1276.GPIOWrite(SPI1_NSS_GPIO_Port,SPI1_NSS_Pin,1);
}

void RxChainCalibration()
{
	uint8_t regPaConfigInitVal;
	uint32_t initialFreq;

	// Save context
	regPaConfigInitVal = SX1276Read( REG_PACONFIG );
	initialFreq = ( double )( ( ( uint32_t )SX1276Read( REG_FRFMSB ) << 16 ) |
							  ( ( uint32_t )SX1276Read( REG_FRFMID ) << 8 ) |
							  ( ( uint32_t )SX1276Read( REG_FRFLSB ) ) ) * ( double )FREQ_STEP;

	// Cut the PA just in case, RFO output, power = -1 dBm
	SX1276Write( REG_PACONFIG, 0x00 );

	// Launch Rx chain calibration for LF band
	SX1276Write( REG_IMAGECAL, ( SX1276Read( REG_IMAGECAL ) & RF_IMAGECAL_IMAGECAL_MASK ) | RF_IMAGECAL_IMAGECAL_START );
	while( ( SX1276Read( REG_IMAGECAL ) & RF_IMAGECAL_IMAGECAL_RUNNING ) == RF_IMAGECAL_IMAGECAL_RUNNING )
	{
	}

	// Sets a Frequency in HF band
	SX1276SetChannel( 868000000 );

	// Launch Rx chain calibration for HF band
	SX1276Write( REG_IMAGECAL, ( SX1276Read( REG_IMAGECAL ) & RF_IMAGECAL_IMAGECAL_MASK ) | RF_IMAGECAL_IMAGECAL_START );
	while( ( SX1276Read( REG_IMAGECAL ) & RF_IMAGECAL_IMAGECAL_RUNNING ) == RF_IMAGECAL_IMAGECAL_RUNNING )
	{
	}

	// Restore context
	SX1276Write( REG_PACONFIG, regPaConfigInitVal );
	SX1276SetChannel( initialFreq );
}

void SX1276SetOpMode(uint8_t OpMode)
{
	switch (OpMode)
	{
		case RFLR_OPMODE_RECEIVER:
		case RFLR_OPMODE_RECEIVER_SINGLE:
			SCI_SX1276.State=SX1276_RX_RUNNING;
			break;
		case RF_OPMODE_TRANSMITTER:
			SCI_SX1276.State=SX1276_TX_RUNNING;
			break;
		default:
			SCI_SX1276.State=SX1276_NORMAL_RUNNING;
			break;
	}

    if( OpMode == RFLR_OPMODE_SLEEP )
    {
        //SX1276SetAntSwLowPower( true );
    	HCI_SX1276.DeInitVCTLPin();
    }
    else
    {
        //SX1276SetAntSwLowPower( false );
    	HCI_SX1276.InitVCTLPin();
        SX1276SetAntSw( OpMode );
    }
    volatile uint8_t temp;
    temp=SX1276Read( REG_OPMODE );

    SX1276Write( REG_OPMODE, ( temp & RF_OPMODE_MASK ) | OpMode );
    temp=SX1276Read( REG_OPMODE );
}

void SX1276SetModem( RadioModems_t modem )
{
	//if (modem==MODEM_FSK) return;
    volatile uint8_t temp;
    temp=SX1276Read( REG_OPMODE );
    assert_param( ( &hspi1.Instance != NULL ) );

    if( ( temp & RFLR_OPMODE_LONGRANGEMODE_ON ) != 0 )
    {
        SCI_SX1276.Modem = MODEM_LORA;
    }
    else
    {
    	SCI_SX1276.Modem = MODEM_FSK;
    }

    if( SCI_SX1276.Modem == modem )
    {
        return;
    }

    SCI_SX1276.Modem = modem;
    switch( SCI_SX1276.Modem )
    {
    default:
    case MODEM_FSK:
        SX1276Sleep( );
        temp=SX1276Read( REG_OPMODE );
        SX1276Write( REG_OPMODE, ( temp & RFLR_OPMODE_LONGRANGEMODE_MASK ) | RFLR_OPMODE_LONGRANGEMODE_OFF );

        SX1276Write( REG_DIOMAPPING1, 0x00 );
        SX1276Write( REG_DIOMAPPING2, 0x30 ); // DIO5=ModeReady
        break;
    case MODEM_LORA:
        SX1276Sleep( );
        temp=SX1276Read( REG_OPMODE );
        SX1276Write( REG_OPMODE, ( temp & RFLR_OPMODE_LONGRANGEMODE_MASK ) | RFLR_OPMODE_LONGRANGEMODE_ON );

        SX1276Write( REG_DIOMAPPING1, 0x00 );
        SX1276Write( REG_DIOMAPPING2, 0x00 );
        break;
    }
}

void SX1276SetPublicNetwork( bool enable )
{
    SX1276SetModem( MODEM_LORA );
    //SX1276.Settings.LoRa.PublicNetwork = enable;
    if( enable == true )
    {
        // Change LoRa modem SyncWord
        SX1276Write( REG_LR_SYNCWORD, LORA_MAC_PUBLIC_SYNCWORD );
    }
    else
    {
        // Change LoRa modem SyncWord
        SX1276Write( REG_LR_SYNCWORD, LORA_MAC_PRIVATE_SYNCWORD );
    }
}

void SX1276Sleep()
{
	SX1276SetOpMode( RF_OPMODE_SLEEP );
}

void SX1276PrepareFrame(uint8_t *Data, uint16_t size)
{
	for (uint16_t i=0;i<size;i++)
	{
		SCI_SX1276.buffer[i]=Data[i];
	}
	SCI_SX1276.length=size;
}

void SX1276SetChannel(uint32_t freq)
{
    //SX1276.Settings.Channel = freq;
    freq = ( uint32_t )( ( double )freq / ( double )FREQ_STEP );

    SX1276Write( REG_FRFMSB, ( uint8_t )( ( freq >> 16 ) & 0xFF ) );
    SX1276Write( REG_FRFMID, ( uint8_t )( ( freq >> 8 ) & 0xFF ) );
    SX1276Write( REG_FRFLSB, ( uint8_t )( freq & 0xFF ) );

    SCI_SX1276.channel=freq;
}

void SX1276SetMacPayloadLength(RadioModems_t Modem, uint8_t length)
{
    SX1276SetModem( Modem );

    switch( Modem )
    {
    case MODEM_FSK:
        /*if( SX1276.Settings.Fsk.FixLen == false )
        {
            SX1276Write( REG_PAYLOADLENGTH, max );
        }*/
        break;
    case MODEM_LORA:
        SX1276Write( REG_LR_PAYLOADMAXLENGTH, length );
        break;
    }
}

void SX1276SetTxConfig(TxConfig_t TxConfig)//( RadioModems_t modem, int8_t power, uint32_t fdev,
        //uint32_t bandwidth, uint32_t datarate,
        //uint8_t coderate, uint16_t preambleLen,
        //bool fixLen, bool crcOn, bool freqHopOn,
        //uint8_t hopPeriod, bool iqInverted, uint32_t timeout )
{
	RadioModems_t 	modem			= TxConfig.Modem_Type;
	int8_t 			power			= TxConfig.TxPower;
	uint32_t 		fdev			= TxConfig.fDev;
	uint32_t 		bandwidth		= TxConfig.Bandwidth;
	uint32_t 		datarate		= TxConfig.Datarate;
	uint8_t 		coderate		= TxConfig.Coderate;
	uint16_t 		preambleLen		= TxConfig.PreambleLen;
	bool 			fixLen			= TxConfig.FixLen;
	bool 			crcOn			= TxConfig.CrcOn;
	bool 			freqHopOn		= TxConfig.FreqHopOn;
	uint8_t 		hopPeriod		= TxConfig.HopPeriod;
	bool 			iqInverted		= TxConfig.IqInverted;
	uint32_t 		timeout			= TxConfig.Timeout;


	SX1276SetModem( modem );
	SX1276SetRfTxPower( power );
	uint8_t LowDatarateOptimize;

	switch( modem )
	    {
	    case MODEM_FSK:
	    	break;
	    case MODEM_LORA:
	    	bandwidth += 7;

	    	if( datarate > 12 )
				{
					datarate = 12;
				}
				else if( datarate < 6 )
				{
					datarate = 6;
				}
				if( ( ( bandwidth == 7 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
					( ( bandwidth == 8 ) && ( datarate == 12 ) ) )
				{
					LowDatarateOptimize = 0x01;
				}
				else
				{
					LowDatarateOptimize = 0x00;
	    	    }

	    	if(freqHopOn == true )
				{
					SX1276Write( REG_LR_PLLHOP, ( SX1276Read( REG_LR_PLLHOP ) & RFLR_PLLHOP_FASTHOP_MASK ) | RFLR_PLLHOP_FASTHOP_ON );
					SX1276Write( REG_LR_HOPPERIOD, hopPeriod );
				}

	    	SX1276Write( REG_LR_MODEMCONFIG1,
	    	                         ( SX1276Read( REG_LR_MODEMCONFIG1 ) &
	    	                           RFLR_MODEMCONFIG1_BW_MASK &
	    	                           RFLR_MODEMCONFIG1_CODINGRATE_MASK &
	    	                           RFLR_MODEMCONFIG1_IMPLICITHEADER_MASK ) |
	    	                           ( bandwidth << 4 ) | ( coderate << 1 ) |
	    	                           fixLen );

			SX1276Write( REG_LR_MODEMCONFIG2,
						 ( SX1276Read( REG_LR_MODEMCONFIG2 ) &
						   RFLR_MODEMCONFIG2_SF_MASK &
						   RFLR_MODEMCONFIG2_RXPAYLOADCRC_MASK ) |
						   ( datarate << 4 ) | ( crcOn << 2 ) );

			SX1276Write( REG_LR_MODEMCONFIG3,
						 ( SX1276Read( REG_LR_MODEMCONFIG3 ) &
						   RFLR_MODEMCONFIG3_LOWDATARATEOPTIMIZE_MASK ) |
						   (LowDatarateOptimize << 3 ) );

			SX1276Write( REG_LR_PREAMBLEMSB, ( preambleLen >> 8 ) & 0x00FF );
			SX1276Write( REG_LR_PREAMBLELSB, preambleLen & 0xFF );

			if( datarate == 6 )
			{
				SX1276Write( REG_LR_DETECTOPTIMIZE,
							 ( SX1276Read( REG_LR_DETECTOPTIMIZE ) &
							   RFLR_DETECTIONOPTIMIZE_MASK ) |
							   RFLR_DETECTIONOPTIMIZE_SF6 );
				SX1276Write( REG_LR_DETECTIONTHRESHOLD,
							 RFLR_DETECTIONTHRESH_SF6 );
			}
			else
			{
				SX1276Write( REG_LR_DETECTOPTIMIZE,
							 ( SX1276Read( REG_LR_DETECTOPTIMIZE ) &
							 RFLR_DETECTIONOPTIMIZE_MASK ) |
							 RFLR_DETECTIONOPTIMIZE_SF7_TO_SF12 );
				SX1276Write( REG_LR_DETECTIONTHRESHOLD,
							 RFLR_DETECTIONTHRESH_SF7_TO_SF12 );
			}
			break;
	    }
}

void SX1276Send(TxConfig_t TxConfig)
{
	/*uint32_t freq=Tx;
	uint8_t txPower =TxPowers[4];
	uint8_t datarate =Datarates[0];
	uint32_t fdev=0;
	uint32_t bandwidth=0;
	uint8_t coderate=1;
	uint16_t preambleLen=8;
	bool fixLen=false;
	bool crcOn=true;
	bool freqHopOn=0;
	uint8_t hopPeriod=0;
	bool iqInverted=false;
	uint32_t timeout=3e3;*/

	HCI_SX1276.GPIOWrite(VCTL1_GPIO_Port,VCTL1_Pin,1);
	HCI_SX1276.GPIOWrite(VCTL2_GPIO_Port,VCTL2_Pin,0);

	SX1276SetChannel(TxConfig.Frequency);
	SX1276SetMacPayloadLength(MODEM_LORA, SCI_SX1276.length);
	//SetTxConfig( MODEM_LORA, txPower, 0, 0, datarate, 1, 8, false, true, 0, 0, false, 3e3 );
	//SX1276SetTxConfig( MODEM_LORA, txPower, fdev, bandwidth, datarate, coderate, preambleLen, fixLen, crcOn, freqHopOn, hopPeriod, iqInverted, timeout );
	SX1276SetTxConfig(TxConfig);
	if( TxConfig.IqInverted == true )
	{
		SX1276Write( REG_LR_INVERTIQ, ( ( SX1276Read( REG_LR_INVERTIQ ) & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK ) | RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_ON ) );
		SX1276Write( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON );
	}
	else
	{
		SX1276Write( REG_LR_INVERTIQ, ( ( SX1276Read( REG_LR_INVERTIQ ) & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK ) | RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_OFF ) );
		SX1276Write( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF );
	}

	// Initializes the payload size
	SX1276Write( REG_LR_PAYLOADLENGTH, SCI_SX1276.length );

	// Full buffer used for Tx
	SX1276Write( REG_LR_FIFOTXBASEADDR, 0 );
	SX1276Write( REG_LR_FIFOADDRPTR, 0 );
	volatile uint8_t tmp=SX1276Read(REG_OPMODE);
	// FIFO operations can not take place in Sleep mode
	if( ( SX1276Read( REG_OPMODE ) & ~RF_OPMODE_MASK ) == RF_OPMODE_SLEEP )
	{
		SX1276SetStby( );
		HCI_SX1276.Delay( 10 );
	}
	// Write payload buffer
	SX1276WriteBuffer(0, SCI_SX1276.buffer, SCI_SX1276.length );
	//SX1276SetTx();

	if( TxConfig.FreqHopOn == true )
	{
		SX1276Write( REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
										  RFLR_IRQFLAGS_RXDONE |
										  RFLR_IRQFLAGS_PAYLOADCRCERROR |
										  RFLR_IRQFLAGS_VALIDHEADER |
										  //RFLR_IRQFLAGS_TXDONE |
										  RFLR_IRQFLAGS_CADDONE |
										  //RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
										  RFLR_IRQFLAGS_CADDETECTED );

		// DIO0=TxDone, DIO2=FhssChangeChannel
		SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RFLR_DIOMAPPING1_DIO0_MASK & RFLR_DIOMAPPING1_DIO2_MASK ) | RFLR_DIOMAPPING1_DIO0_01 | RFLR_DIOMAPPING1_DIO2_00 );
	}
	else
	{
		SX1276Write( REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
										  RFLR_IRQFLAGS_RXDONE |
										  RFLR_IRQFLAGS_PAYLOADCRCERROR |
										  RFLR_IRQFLAGS_VALIDHEADER |
										  //RFLR_IRQFLAGS_TXDONE |
										  RFLR_IRQFLAGS_CADDONE |
										  RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
										  RFLR_IRQFLAGS_CADDETECTED );

		// DIO0=TxDone
		SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RFLR_DIOMAPPING1_DIO0_MASK ) | RFLR_DIOMAPPING1_DIO0_01 );
	}

	SX1276SetOpMode( RF_OPMODE_TRANSMITTER );
}

void SX1276SetStby()
{
	SX1276SetOpMode( RF_OPMODE_STANDBY );
}

void SX1276SetRfTxPower( int8_t power )
{
    uint8_t paConfig = 0;
    uint8_t paDac = 0;

    paConfig = SX1276Read( REG_PACONFIG );
    paDac = SX1276Read( REG_PADAC );

    paConfig = ( paConfig & RF_PACONFIG_PASELECT_MASK ) | RF_PACONFIG_PASELECT_PABOOST;//SX1276GetPaSelect( SX1276.Settings.Channel );
    paConfig = ( paConfig & RF_PACONFIG_MAX_POWER_MASK ) | 0x70;

    if( ( paConfig & RF_PACONFIG_PASELECT_PABOOST ) == RF_PACONFIG_PASELECT_PABOOST )
    {
        if( power > 17 )
        {
            paDac = ( paDac & RF_PADAC_20DBM_MASK ) | RF_PADAC_20DBM_ON;
        }
        else
        {
            paDac = ( paDac & RF_PADAC_20DBM_MASK ) | RF_PADAC_20DBM_OFF;
        }
        if( ( paDac & RF_PADAC_20DBM_ON ) == RF_PADAC_20DBM_ON )
        {
            if( power < 5 )
            {
                power = 5;
            }
            if( power > 20 )
            {
                power = 20;
            }
            paConfig = ( paConfig & RF_PACONFIG_OUTPUTPOWER_MASK ) | ( uint8_t )( ( uint16_t )( power - 5 ) & 0x0F );
        }
        else
        {
            if( power < 2 )
            {
                power = 2;
            }
            if( power > 17 )
            {
                power = 17;
            }
            paConfig = ( paConfig & RF_PACONFIG_OUTPUTPOWER_MASK ) | ( uint8_t )( ( uint16_t )( power - 2 ) & 0x0F );
        }
    }
    else
    {
        if( power < -1 )
        {
            power = -1;
        }
        if( power > 14 )
        {
            power = 14;
        }
        paConfig = ( paConfig & RF_PACONFIG_OUTPUTPOWER_MASK ) | ( uint8_t )( ( uint16_t )( power + 1 ) & 0x0F );
    }
    SX1276Write( REG_PACONFIG, paConfig );
    SX1276Write( REG_PADAC, paDac );
}

void SX1276SetAntSw( uint8_t opMode )
{
	//RAK4200 edit VCTL here
    switch( opMode )
    {
    case RFLR_OPMODE_TRANSMITTER:
    	HCI_SX1276.GPIOWrite(VCTL1_GPIO_Port,VCTL1_Pin,1);
    	HCI_SX1276.GPIOWrite(VCTL2_GPIO_Port,VCTL2_Pin,0);
        break;
    case RFLR_OPMODE_RECEIVER:
    case RFLR_OPMODE_RECEIVER_SINGLE:
    case RFLR_OPMODE_CAD:
    default:

    	HCI_SX1276.GPIOWrite(VCTL1_GPIO_Port,VCTL1_Pin,0);
    	HCI_SX1276.GPIOWrite(VCTL2_GPIO_Port,VCTL2_Pin,1);
        break;
    }
}



void OnTxDone(void)
{
	SCI_SX1276.print("SX1276 Log: TX Package Sent Out");
	SCI_SX1276.State=SX1276_NORMAL_RUNNING;
	SX1276Write( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_TXDONE );
	//SCI_SX1276.Sleep();
	SCI_SX1276.UserFunction.OnTxDone();
}

void OnTxTimeout(void)
{
	SCI_SX1276.State=SX1276_NORMAL_RUNNING;
	SCI_SX1276.Sleep();
	SCI_SX1276.print("SX1276 Log: Error While Sending Out TX Package. Please Recheck Hardware/Firmware Connection");
	SCI_SX1276.UserFunction.OnTxTimeout();
}

void OnRxDone(uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr)
{
	SCI_SX1276.State=SX1276_NORMAL_RUNNING;
	//SCI_SX1276.Sleep();
	SCI_SX1276.print("SX1276 Log: RX Package Received");
	SCI_SX1276.UserFunction.OnRxDone(payload,size,rssi,snr);
}

void OnRxWindow1Timeout(void)
{
	SCI_SX1276.State=SX1276_NORMAL_RUNNING;
	SCI_SX1276.print("SX1276 Log: RX Window1 Timeout");
	SCI_SX1276.UserFunction.OnRxWindow1Timeout();
}

void OnRxWindow2Timeout(void)
{
	SCI_SX1276.State=SX1276_NORMAL_RUNNING;
	SCI_SX1276.Sleep();
	SCI_SX1276.print("SX1276 Log: RX Window2 Timeout. No RX Package Has Been Received!");
	SCI_SX1276.UserFunction.OnRxWindow2Timeout();
}

void getRxData()
{
	int8_t snr = 0;
	uint8_t irqFlags;

	SX1276Write( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXDONE );

	irqFlags = SX1276Read( REG_LR_IRQFLAGS );
	if( ( irqFlags & RFLR_IRQFLAGS_PAYLOADCRCERROR_MASK ) == RFLR_IRQFLAGS_PAYLOADCRCERROR )
	{
		// Clear Irq
		SX1276Write( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_PAYLOADCRCERROR );

		//TimerStop( &RxTimeoutTimer );

		SCI_SX1276.print("SX1276 Log: RX Package CRC ERROR");
		return;
	}

	SCI_SX1276.PacketHandler.SnrValue = SX1276Read( REG_LR_PKTSNRVALUE );
	if( SCI_SX1276.PacketHandler.SnrValue & 0x80 ) // The SNR sign bit is 1
	{
		// Invert and divide by 4
		snr = ( ( ~SCI_SX1276.PacketHandler.SnrValue + 1 ) & 0xFF ) >> 2;
		snr = -snr;
	}
	else
	{
		// Divide by 4
		snr = ( SCI_SX1276.PacketHandler.SnrValue & 0xFF ) >> 2;
	}

	int16_t rssi = SX1276Read( REG_LR_PKTRSSIVALUE );
	if( snr < 0 )
	{
		if( SCI_SX1276.channel > RF_MID_BAND_THRESH )
		{
			SCI_SX1276.PacketHandler.RssiValue = RSSI_OFFSET_HF + rssi + ( rssi >> 4 ) +
														  snr;
		}
		else
		{
			SCI_SX1276.PacketHandler.RssiValue = RSSI_OFFSET_LF + rssi + ( rssi >> 4 ) +
														  snr;
		}
	}
	else
	{
		if( SCI_SX1276.channel > RF_MID_BAND_THRESH )
		{
			SCI_SX1276.PacketHandler.RssiValue = RSSI_OFFSET_HF + rssi + ( rssi >> 4 );
		}
		else
		{
			SCI_SX1276.PacketHandler.RssiValue = RSSI_OFFSET_LF + rssi + ( rssi >> 4 );
		}
	}

	SCI_SX1276.PacketHandler.Size = SX1276Read( REG_LR_RXNBBYTES );
	SX1276ReadBuffer(0, SCI_SX1276.buffer, SCI_SX1276.PacketHandler.Size );
	OnRxDone( SCI_SX1276.buffer, SCI_SX1276.PacketHandler.Size, SCI_SX1276.PacketHandler.RssiValue, SCI_SX1276.PacketHandler.SnrValue );


	//TimerStop( &RxTimeoutTimer );
}

void DIO0_IRQ(void)
{
	SCI_SX1276.print("SX1276 Log: DIO0 Has Been Interrupt");
	switch (SCI_SX1276.State)
	{
		case SX1276_TX_RUNNING:
			OnTxDone();
			break;

		case SX1276_RX_RUNNING:
			//OnRxDone();
			getRxData();
			break;

		default:
			break;
	}
}

void DIO1_IRQ(void)
{
	SCI_SX1276.print("SX1276 Log: DIO1 Has Been Interrupt");
	SCI_SX1276.UserFunction.DIO1_IRQ();
}

void DIO2_IRQ(void)
{
	SCI_SX1276.print("SX1276 Log: DIO2 Has Been Interrupt");
	SCI_SX1276.UserFunction.DIO2_IRQ();
}

void DIO3_IRQ(void)
{
	SCI_SX1276.print("SX1276 Log: DIO3 Has Been Interrupt");
	SCI_SX1276.UserFunction.DIO3_IRQ();
}

void SX1276Init( )
{
    uint8_t i;
    SCI_SX1276.InitDone=false;

    HCI_SX1276.InitSPI();
    HCI_SX1276.InitGPIO();


    SCI_SX1276.UserFunction.DIO0_IRQ= &NullFunction;
    SCI_SX1276.UserFunction.DIO1_IRQ= &NullFunction;
    SCI_SX1276.UserFunction.DIO2_IRQ= &NullFunction;
    SCI_SX1276.UserFunction.DIO3_IRQ= &NullFunction;
    SCI_SX1276.UserFunction.OnRxDone= &NullFunction;
    SCI_SX1276.UserFunction.OnRxWindow1Timeout= &NullFunction;
    SCI_SX1276.UserFunction.OnRxWindow2Timeout= &NullFunction;
    SCI_SX1276.UserFunction.OnTxDone= &NullFunction;
    SCI_SX1276.UserFunction.OnTxTimeout= &NullFunction;

    //RadioEvents = events;

    // Initialize driver timeout timers
    //TimerInit( &TxTimeoutTimer, SX1276OnTimeoutIrq );
    //TimerInit( &RxTimeoutTimer, SX1276OnTimeoutIrq );
    //TimerInit( &RxTimeoutSyncWord, SX1276OnTimeoutIrq );

    SX1276Reset( );

    RxChainCalibration( );

    SX1276SetOpMode( RF_OPMODE_SLEEP );

    //SX1276IoIrqInit( DioIrq );

    for( i = 0; i < sizeof( RadioRegsInit ) / sizeof( RadioRegisters_t ); i++ )
    {
        SX1276SetModem( RadioRegsInit[i].Modem );
        SX1276Write( RadioRegsInit[i].Addr, RadioRegsInit[i].Value );
    }

    SX1276SetModem( MODEM_FSK );
    srand1(SX1276Random());
    SX1276SetPublicNetwork(true);

    SCI_SX1276.State=SX1276_NORMAL_RUNNING;
    //SX1276.Settings.State = RF_IDLE;
    SCI_SX1276.InitDone=true;


}

void SX1276SetTx(bool FreqHopOn)
{
	if( FreqHopOn == true )
	{
		SX1276Write( REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
										  RFLR_IRQFLAGS_RXDONE |
										  RFLR_IRQFLAGS_PAYLOADCRCERROR |
										  RFLR_IRQFLAGS_VALIDHEADER |
										  //RFLR_IRQFLAGS_TXDONE |
										  RFLR_IRQFLAGS_CADDONE |
										  //RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
										  RFLR_IRQFLAGS_CADDETECTED );

		// DIO0=TxDone, DIO2=FhssChangeChannel
		SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RFLR_DIOMAPPING1_DIO0_MASK & RFLR_DIOMAPPING1_DIO2_MASK ) | RFLR_DIOMAPPING1_DIO0_01 | RFLR_DIOMAPPING1_DIO2_00 );
	}
	else
	{
		SX1276Write( REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
										  RFLR_IRQFLAGS_RXDONE |
										  RFLR_IRQFLAGS_PAYLOADCRCERROR |
										  RFLR_IRQFLAGS_VALIDHEADER |
										  //RFLR_IRQFLAGS_TXDONE |
										  RFLR_IRQFLAGS_CADDONE |
										  RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
										  RFLR_IRQFLAGS_CADDETECTED );

		// DIO0=TxDone
		SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RFLR_DIOMAPPING1_DIO0_MASK ) | RFLR_DIOMAPPING1_DIO0_01 );
	}
}

void SetUserFunction(SX1276_UserFunction_t UserFunction)
{
	SCI_SX1276.UserFunction=UserFunction;
}

uint32_t SX1276Random( void )
{
    uint8_t i;
    uint32_t rnd = 0;

    /*
     * Radio setup for random number generation
     */
    // Set LoRa modem ON
    SX1276SetModem( MODEM_LORA );

    // Disable LoRa modem interrupts
    SX1276Write( REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
                  RFLR_IRQFLAGS_RXDONE |
                  RFLR_IRQFLAGS_PAYLOADCRCERROR |
                  RFLR_IRQFLAGS_VALIDHEADER |
                  RFLR_IRQFLAGS_TXDONE |
                  RFLR_IRQFLAGS_CADDONE |
                  RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                  RFLR_IRQFLAGS_CADDETECTED );

    // Set radio in continuous reception
    SX1276SetOpMode( RF_OPMODE_RECEIVER );

    for( i = 0; i < 32; i++ )
    {
        // Unfiltered RSSI value reading. Only takes the LSB value
        rnd |= ( ( uint32_t )SX1276Read( REG_LR_RSSIWIDEBAND ) & 0x01 ) << i;
    }

    SX1276Sleep( );

    return rnd;
}

void NullFunction(void)
{

}

static bool SX1276RxWindowSetup(RxConfig_t RxConfig)//( uint32_t freq, int8_t datarate, uint32_t bandwidth, uint16_t timeout, bool rxContinuous, uint32_t maxRxWindow, bool IqInverted )
{

    if( SCI_SX1276.State == SX1276_NORMAL_RUNNING )
    {
        SX1276SetChannel( RxConfig.Frequency );

        // Store downlink datarate
        //McpsIndication.RxDatarate = ( uint8_t ) datarate;

#if defined( USE_BAND_433 ) || defined( USE_BAND_780 ) || defined( USE_BAND_868 )

		SX1276SetRxConfig(RxConfig);//( MODEM_LORA, RxConfig.Bandwidth, downlinkDatarate, 1, 0, 8, RxConfig.SymbTimeout, false, 0, false, 0, 0, true, RxConfig.RxContinuous );

#elif defined( USE_BAND_470 ) || defined( USE_BAND_915 ) || defined( USE_BAND_915_HYBRID )
        modem = MODEM_LORA;
        Radio.SetRxConfig( modem, bandwidth, downlinkDatarate, 1, 0, 8, timeout, false, 0, false, 0, 0, true, rxContinuous );
#endif

        SX1276SetMacPayloadLength( RxConfig.Modem_Type, RxConfig.MaxPayload + LORA_MAC_FRMPAYLOAD_OVERHEAD );

		SX1276SetRx( RxConfig);
		//printf("Radio.Rx %d",LoRaMacParams.MaxRxWindow);
        return true;
    }
    return false;
}

void SX1276SetRxConfig(RxConfig_t _RxConfig)
{
	RxConfig_t RxConfig=_RxConfig;
	bool LowDatarateOptimize;
    SX1276SetModem( RxConfig.Modem_Type );
    switch (RxConfig.Modem_Type)
    {
    	case MODEM_FSK:
    		SCI_SX1276.print('Failed. FSK Mode is not supported');
    		break;
    	case MODEM_LORA:
    	{
			if( RxConfig.Bandwidth > 2 )
			{
				// Fatal error: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported
				SCI_SX1276.print("When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported. Return");
				return;
			}
			RxConfig.Bandwidth += 7;
			volatile tmp=RxConfig.Bandwidth;

			if( RxConfig.Datarate > 12 )
			{
				RxConfig.Datarate = 12;
			}
			else if( RxConfig.Datarate < 6 )
			{
				RxConfig.Datarate = 6;
			}

			if( ( ( RxConfig.Bandwidth == 7 ) && ( ( RxConfig.Datarate == 11 ) || ( RxConfig.Datarate == 12 ) ) ) ||
				( ( RxConfig.Bandwidth == 8 ) && ( RxConfig.Datarate == 12 ) ) )
			{
				LowDatarateOptimize = 0x01;
			}
			else
			{
				LowDatarateOptimize = 0x00;
			}

			SX1276Write( REG_LR_MODEMCONFIG1,
						 ( SX1276Read( REG_LR_MODEMCONFIG1 ) &
						   RFLR_MODEMCONFIG1_BW_MASK &
						   RFLR_MODEMCONFIG1_CODINGRATE_MASK &
						   RFLR_MODEMCONFIG1_IMPLICITHEADER_MASK ) |
						   ( RxConfig.Bandwidth << 4 ) | ( RxConfig.Coderate << 1 ) |
						   RxConfig.FixLen );

			SX1276Write( REG_LR_MODEMCONFIG2,
						 ( SX1276Read( REG_LR_MODEMCONFIG2 ) &
						   RFLR_MODEMCONFIG2_SF_MASK &
						   RFLR_MODEMCONFIG2_RXPAYLOADCRC_MASK &
						   RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK ) |
						   ( RxConfig.Datarate << 4 ) | ( RxConfig.CrcOn << 2 ) |
						   ( ( RxConfig.SymbTimeout >> 8 ) & ~RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK ) );

			SX1276Write( REG_LR_MODEMCONFIG3,
						 ( SX1276Read( REG_LR_MODEMCONFIG3 ) &
						   RFLR_MODEMCONFIG3_LOWDATARATEOPTIMIZE_MASK ) |
						   ( LowDatarateOptimize << 3 ) );

			SX1276Write( REG_LR_SYMBTIMEOUTLSB, ( uint8_t )( RxConfig.SymbTimeout & 0xFF ) );

			SX1276Write( REG_LR_PREAMBLEMSB, ( uint8_t )( ( RxConfig.PreambleLen >> 8 ) & 0xFF ) );
			SX1276Write( REG_LR_PREAMBLELSB, ( uint8_t )( RxConfig.PreambleLen & 0xFF ) );

			if( RxConfig.FixLen == 1 )
			{
				SX1276Write( REG_LR_PAYLOADLENGTH, RxConfig.PayloadLen );
			}

			if( RxConfig.FreqHopOn == true )
			{
				SX1276Write( REG_LR_PLLHOP, ( SX1276Read( REG_LR_PLLHOP ) & RFLR_PLLHOP_FASTHOP_MASK ) | RFLR_PLLHOP_FASTHOP_ON );
				SX1276Write( REG_LR_HOPPERIOD, RxConfig.HopPeriod );
			}

			if( ( RxConfig.Bandwidth == 9 ) && ( SCI_SX1276.channel > RF_MID_BAND_THRESH ) )
			{
				// ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
				SX1276Write( REG_LR_TEST36, 0x02 );
				SX1276Write( REG_LR_TEST3A, 0x64 );
			}
			else if( RxConfig.Bandwidth == 9 )
			{
				// ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
				SX1276Write( REG_LR_TEST36, 0x02 );
				SX1276Write( REG_LR_TEST3A, 0x7F );
			}
			else
			{
				// ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
				SX1276Write( REG_LR_TEST36, 0x03 );
			}

			if( RxConfig.Datarate == 6 )
			{
				SX1276Write( REG_LR_DETECTOPTIMIZE,
							 ( SX1276Read( REG_LR_DETECTOPTIMIZE ) &
							   RFLR_DETECTIONOPTIMIZE_MASK ) |
							   RFLR_DETECTIONOPTIMIZE_SF6 );
				SX1276Write( REG_LR_DETECTIONTHRESHOLD,
							 RFLR_DETECTIONTHRESH_SF6 );
			}
			else
			{
				SX1276Write( REG_LR_DETECTOPTIMIZE,
							 ( SX1276Read( REG_LR_DETECTOPTIMIZE ) &
							 RFLR_DETECTIONOPTIMIZE_MASK ) |
							 RFLR_DETECTIONOPTIMIZE_SF7_TO_SF12 );
				SX1276Write( REG_LR_DETECTIONTHRESHOLD,
							 RFLR_DETECTIONTHRESH_SF7_TO_SF12 );
			}
		}
		break;
    }

}

void SX1276SetRx( RxConfig_t RxConfig )
{
    bool rxContinuous = false;

    switch( SCI_SX1276.Modem )
    {
    case MODEM_FSK:
        {
            SCI_SX1276.print("Failed. FSK Mode is not supported");
        }
        break;
    case MODEM_LORA:
        {
            if( RxConfig.IqInverted == true )
            {
                SX1276Write( REG_LR_INVERTIQ, ( ( SX1276Read( REG_LR_INVERTIQ ) & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK ) | RFLR_INVERTIQ_RX_ON | RFLR_INVERTIQ_TX_OFF ) );
                SX1276Write( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON );
            }
            else
            {
                SX1276Write( REG_LR_INVERTIQ, ( ( SX1276Read( REG_LR_INVERTIQ ) & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK ) | RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_OFF ) );
                SX1276Write( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF );
            }

            // ERRATA 2.3 - Receiver Spurious Reception of a LoRa Signal
            if( RxConfig.Bandwidth+7 < 9 )
            {
                SX1276Write( REG_LR_DETECTOPTIMIZE, SX1276Read( REG_LR_DETECTOPTIMIZE ) & 0x7F );
                SX1276Write( REG_LR_TEST30, 0x00 );
                switch( RxConfig.Bandwidth + 7 )
                {
                case 0: // 7.8 kHz
                    SX1276Write( REG_LR_TEST2F, 0x48 );
                    SX1276SetChannel(SCI_SX1276.channel + 7.81e3 );
                    break;
                case 1: // 10.4 kHz
                    SX1276Write( REG_LR_TEST2F, 0x44 );
                    SX1276SetChannel(SCI_SX1276.channel + 10.42e3 );
                    break;
                case 2: // 15.6 kHz
                    SX1276Write( REG_LR_TEST2F, 0x44 );
                    SX1276SetChannel(SCI_SX1276.channel + 15.62e3 );
                    break;
                case 3: // 20.8 kHz
                    SX1276Write( REG_LR_TEST2F, 0x44 );
                    SX1276SetChannel(SCI_SX1276.channel + 20.83e3 );
                    break;
                case 4: // 31.2 kHz
                    SX1276Write( REG_LR_TEST2F, 0x44 );
                    SX1276SetChannel(SCI_SX1276.channel + 31.25e3 );
                    break;
                case 5: // 41.4 kHz
                    SX1276Write( REG_LR_TEST2F, 0x44 );
                    SX1276SetChannel(SCI_SX1276.channel + 41.67e3 );
                    break;
                case 6: // 62.5 kHz
                    SX1276Write( REG_LR_TEST2F, 0x40 );
                    break;
                case 7: // 125 kHz
                    SX1276Write( REG_LR_TEST2F, 0x40 );
                    break;
                case 8: // 250 kHz
                    SX1276Write( REG_LR_TEST2F, 0x40 );
                    break;
                }
            }
            else
            {
                SX1276Write( REG_LR_DETECTOPTIMIZE, SX1276Read( REG_LR_DETECTOPTIMIZE ) | 0x80 );
            }

            //rxContinuous = SX1276.Settings.LoRa.RxContinuous;

            if( RxConfig.FreqHopOn == true )
            {
                SX1276Write( REG_LR_IRQFLAGSMASK, //RFLR_IRQFLAGS_RXTIMEOUT |
                                                  //RFLR_IRQFLAGS_RXDONE |
                                                  //RFLR_IRQFLAGS_PAYLOADCRCERROR |
                                                  RFLR_IRQFLAGS_VALIDHEADER |
                                                  RFLR_IRQFLAGS_TXDONE |
                                                  RFLR_IRQFLAGS_CADDONE |
                                                  //RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                                                  RFLR_IRQFLAGS_CADDETECTED );

                // DIO0=RxDone, DIO2=FhssChangeChannel
                SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RFLR_DIOMAPPING1_DIO0_MASK & RFLR_DIOMAPPING1_DIO2_MASK  ) | RFLR_DIOMAPPING1_DIO0_00 | RFLR_DIOMAPPING1_DIO2_00 );
            }
            else
            {
                SX1276Write( REG_LR_IRQFLAGSMASK, //RFLR_IRQFLAGS_RXTIMEOUT |
                                                  //RFLR_IRQFLAGS_RXDONE |
                                                  //RFLR_IRQFLAGS_PAYLOADCRCERROR |
                                                  RFLR_IRQFLAGS_VALIDHEADER |
                                                  RFLR_IRQFLAGS_TXDONE |
                                                  RFLR_IRQFLAGS_CADDONE |
                                                  RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                                                  RFLR_IRQFLAGS_CADDETECTED );

                // DIO0=RxDone
                SX1276Write( REG_DIOMAPPING1, ( SX1276Read( REG_DIOMAPPING1 ) & RFLR_DIOMAPPING1_DIO0_MASK ) | RFLR_DIOMAPPING1_DIO0_00 );
            }
            SX1276Write( REG_LR_FIFORXBASEADDR, 0 );
            SX1276Write( REG_LR_FIFOADDRPTR, 0 );
        }
        break;
    }

    memset( SCI_SX1276.buffer, 0, ( size_t )RX_BUFFER_SIZE );

    SCI_SX1276.State = SX1276_RX_RUNNING;
	SX1276SetOpMode( RFLR_OPMODE_RECEIVER_SINGLE );


}
